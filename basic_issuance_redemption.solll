// SPDX-License-Identifier: MIT

pragma solidity 0.6.10;

import  "./ISetToken.sol";
import  "./IBasicIssuanceModule.sol";




contract IssueSET {
    
    address public maticAToken = 0x720ddAa73C16B12b5AB6362BacCB504cFd907121 ;
    address public maticBToken = 0x425783dE6E1C57903eD5eb457208eCB9D224965C ;
    address public maticsetTokenPABaddress = 0x0cBD78846F2F63401639e36905b626f136E1ce39;
    IBasicIssuanceModule issuance;
    

	 // see : https://github.com/SetProtocol/set-protocol-v2/blob/master/contracts/protocol/modules/BasicIssuanceModule.sol 
    address public basicIssuanceModuleAddress ;     // deployed BasicIssuanceModule.sol address on Matic TestNet
	                                               
   	 
	ISetToken mySets = ISetToken(maticsetTokenPABaddress);
	   

	   constructor(address _issuance ) public {     // pass the address of deployed BasicIssuanceModule.sol address on Matic TestNet as a constructor parameter when deploying the contract
	       
	        basicIssuanceModuleAddress = _issuance;
	        issuance = IBasicIssuanceModule(basicIssuanceModuleAddress);  // BasicIssuanceModule intialized
	        
	        
	  }
	   

	  /////////////////////////////////////////////////////////////////// SET CONTRACT RELATED FUNCTIONS/////////////////////////////////////////////////////////
	 



 /* ----------------------------------------------------------------------------
     * View only functions related to settoken.sol contract
     * ----------------------------------------------------------------------------
     */

      

	   /**
     * @return list of the module attach with this particular settoken.sol
     */


	 	function getModules()  external view returns (address[] memory) {
			 
			return mySets.getModules() ;
			 
		 }
		 
		 
		 
	 /**
     * @return  true if a particular module is pending to be intilaized in that particular module contract
     */

		 		 
	  function isPendingModule(address _module) external view returns(bool) {
		  
		  address module = _module ;
		  
		  return  mySets.isPendingModule(module);
	  }
		 
		 
	 /**
     * @return list of the addresses of the underlying components which form SETTOKEN
     */

	 
	   function getComponents() external view returns(address[] memory) {
		   
		   return  mySets.getComponents();
	   }
	   
	     
   

 /////////////////////////////////////////////////////////////////// BASIC ISSUANCE  RELATED FUNCTIONS/////////////////////////////////////////////////////////
	 

	 /* ============ External Functions ============ */
	
 /**
  * Deposits the SetToken's position components into the SetToken and mints the SetToken of the given quantity
    * to the specified _to address. This function only handles Default Positions (positionState = 0).
     * @dev 
     * @param _setToken  Instance of the SetToken contract
     * @param _quantity  Quantity of the SetToken to mint
     * @param _to        Address to mint SetToken to  

     */

	function issueSET ( ISetToken _setToken , uint256 _quantity, address _to) external {
	   
   
	
	    
     ISetToken mySet = ISetToken(_setToken);    // instantiating Settoken via ISetToken interface by passing address of the SetToken which got generated by SetTokenFactory.sol contract
     uint256 quantity = _quantity;
     address to = _to; 
          
		/**
		  * disable all the below "transferFrom ,"approve" steps while calling the issueSET function from frontend
		  * you need to first approve each of the underlying components(token) from your metamask wallet to this contract address
		  * Once approved,then transfer those approved tokens from  your wallet address (which is EOA) to this contract address
		  * Once all the required underlying components has been transffered to this  contract ,approve "BasicIssuanceModule.sol"
		    to spend those token in behalf of this contract
          *  Once "BasicIssuanceModule.sol" contract has been approved by this contract to spend underlying tokens in behalf
		     of this contract, it will be eligible to issue set


	   * psuedocode ref from frontend
	  
	            mockTokenA.methods.approve(basic_issuance_redemption._address, amount)
	                                .transferFrom(wallet_acc_address ,basic_issuance_redemption._address ,amount )
									.approve(basicIssuanceModuleAddress, amount)
	                                .send({ from: this.state.account }).on('transactionHash', (hash) => { this.state.methods.issueSET...}

				
	            mockTokenB.methods.approve(basic_issuance_redemption._address, amount)
	                                .transferFrom(wallet_acc_address ,basic_issuance_redemption._address ,amount )
									.approve(basicIssuanceModuleAddress, amount)
	                                .send({ from: this.state.account }).on('transactionHash', (hash) => { this.state.methods.issueSET...}
		
		
		 */
	
		
        IERC20(maticAToken).transferFrom( msg.sender ,address(this) ,7000000000000000000000); 
          
        IERC20(maticBToken).transferFrom( msg.sender ,address(this) ,7000000000000000000000);

		IERC20(maticAToken).approve(address(issuance) ,6000000000000000000000);
		IERC20(maticBToken).approve(address(issuance) ,6000000000000000000000);
         
		  // Mint the SetToken
          issuance.issue( mySet , quantity, to); 
                 
 	 }
	 

   

   /**
     * Redeems the SetToken's positions and sends the components of the given
     * quantity to the caller. This function only handles Default Positions (positionState = 0).
     *
     * @param _setToken             Instance of the SetToken contract
     * @param _quantity             Quantity of the SetToken to redeem
     * @param _to                   Address to send component assets to
     */





	 /**
	   *Disale "IERC20(maticsetTokenPABaddress).transferFrom( msg.sender ,address(this) , quantity);" and then deploy the contract to call from frontend
	   *First as now your EOA metamask wallet contains SETTOKENS ,let it approve this contract to spend those required
	    amount of SETTOKEN from the behalf of that wallet address.You can do that either directly via remix console or 
		from frontend
       * Once approved,then transfer those approved tokens from  your wallet address (which is EOA) to this contract address
       * Then once those SETTOKENs which need to be burned to redeem underlying components is being held by this contract,
	     then we are able to redeem by calling redeem function on basicIssuanceModule.sol by this contract
	 
	 
      * psuedocode ref from frontend

         mockTokenA.methods.approve(basic_issuance_redemption._address, amount)
	                                .transferFrom(wallet_acc_address ,basic_issuance_redemption._address ,amount )
									.send({ from: this.state.account }).on('transactionHash', (hash) => { this.state.methods.redeemSET...}
       
	    mockTokenB.methods.approve(basic_issuance_redemption._address, amount)
	                                .transferFrom(wallet_acc_address ,basic_issuance_redemption._address ,amount )
									.send({ from: this.state.account }).on('transactionHash', (hash) => { this.state.methods.redeemSET...}


	  */

	
	function redeemSET ( ISetToken _setToken, uint256 _quantity, address _to) external {
	   
     ISetToken mySet = ISetToken(_setToken);
     uint256 quantity = _quantity;
     address to = _to; 
          
    IERC20(maticsetTokenPABaddress).transferFrom( msg.sender ,address(this) , quantity);

    issuance.redeem( mySet , quantity, to); 
             
 	 }
	 

	/**
     * Retrieves the addresses and units required to mint a particular quantity of SetToken.
     *
     * @param _mySet             Instance of the SetToken to issue
     * @param _quantity             Quantity of SetToken to issue
     * @return address[]            List of component addresses
     * @return uint256[]            List of component units required to issue the quantity of SetTokens
     */


	
	 
	 	 function getRequiredComponentUnitsForIssueData (ISetToken _mySet , uint256 _quantity) external view returns (address[] memory, uint256[] memory) {
	 	     
	 	    
	 	      ISetToken mySet = ISetToken(_mySet);
	 	      uint256 quantity = _quantity;
	 	      
	 	     return issuance.getRequiredComponentUnitsForIssue(mySet , quantity);
	 	 }
	 

	 
    
}












